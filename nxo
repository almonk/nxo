#!/usr/bin/env ruby
require "bundler/setup"
require "dry/cli"

module Nxo
  module CLI
    module Commands
      extend Dry::CLI::Registry
      class Version < Dry::CLI::Command
        desc "Print version"

        def call(*)
          puts "1.0.0"
        end
      end

      class Setup < Dry::CLI::Command
        desc "Initialise a new nix project"

        def call(**args)
          # Write envrc
          File.open(".envrc", "w") {|f| f.write("use nix") }

          # Direnv allow
          system("direnv allow")

          # Write shell.nix
          pkgs = ""

          args[:args].each_with_index do |x,i|
            if i != args[:args].length - 1 
              pkgs += "pkgs." + x + "\n    "
            else
              pkgs += "pkgs." + x
            end
          end

          File.open("shell.nix", "w") {|f| f.write %Q(
{ pkgs ? import <nixpkgs> {}
}:

pkgs.mkShell {
  buildInputs = [
    #{pkgs}
  ];
}
)
          }
          puts "Written ./shell.nix"
        end
      end

      class Append < Dry::CLI::Command
        desc "Append dependencies to shell.nix"

        def call(**args)
          pkgs = []
          shellNix = File.read("./shell.nix")
          pkgsRaw = shellNix.match(/buildInputs = \[\n(.*?)\]/m)[1]
          pkgs = pkgsRaw.split("\n").collect(&:strip!)
          pkgs.pop

          
          puts pkgs.inspect

          # Write shell.nix
          newPkgsString = ""

          pkgs.each_with_index do |x,i|
            newPkgsString += x + "\n    "
          end

          args[:args].each_with_index do |x,i|
            if i != args[:args].length - 1 
              newPkgsString += "pkgs." + x + "\n    "
            else
              newPkgsString += "pkgs." + x
            end
          end

          File.open("shell.nix", "w") {|f| f.write %Q(
{ pkgs ? import <nixpkgs> {}
}:

pkgs.mkShell {
  buildInputs = [
    #{newPkgsString}
  ];
}
)
          }
          puts "Update ./shell.nix"
        end
      end

      class Clean < Dry::CLI::Command
        desc "Remove nix from a project"

        def call(**args)
          cleanupFiles = ["./.envrc", "./shell.nix"]
          cleanupFiles.each do |file|
            File.delete(file) if File.exist?(file)
          end
        end
      end

      register "init",      Setup, aliases: ["i"]
      register "clean",     Clean, aliases: ["c"]
      register "version",   Version, aliases: ["v"]
      register "add",       Append, aliases: ["a"]
    end
  end
end

Dry::CLI.new(Nxo::CLI::Commands).call
